# app/routers/pii_config.py
"""
API endpoints for Dynamic PII Pattern Configuration.
Allows tenants/users to define custom PII patterns with LLM assistance.
"""
import logging
from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field

from app.services.llm_pattern_generator import llm_pattern_generator
from app.database import get_supabase

logger = logging.getLogger("agentshield.pii_config")

router = APIRouter(prefix="/pii", tags=["PII Configuration"])


# Pydantic Models
class PatternGenerateRequest(BaseModel):
    data_type_description: str = Field(..., description="Natural language description of sensitive data")
    context: Optional[str] = Field(None, description="Additional context about the data")
    language: str = Field("es", description="Language for examples")


class PatternGenerateResponse(BaseModel):
    regex_pattern: str
    confidence: float
    test_examples: List[str]
    rationale: str
    pattern_type: str


class CustomP IIPatternCreate(BaseModel):
    pattern_name: str = Field(..., max_length=100)
    pattern_type: str = Field(..., max_length=50)
    regex_pattern: str
    redaction_strategy: str = Field("FULL", regex="^(FULL|PARTIAL|HINT)$")
    
    # Scoping (Tenant ‚Üí Department ‚Üí User hierarchy)
    tenant_id: Optional[UUID] = None
    department_id: Optional[UUID] = None
    user_id: Optional[UUID] = None
    
    # LLM metadata
    generated_by_llm: bool = False
    llm_prompt: Optional[str] = None
    confidence_score: Optional[float] = None
    test_examples: Optional[List[str]] = None


class CustomPIIPatternResponse(BaseModel):
    id: UUID
    pattern_name: str
    pattern_type: str
    regex_pattern: str
    redaction_strategy: str
    is_active: bool
    confidence_score: Optional[float]
    generated_by_llm: bool
    created_at: str


class PatternTestRequest(BaseModel):
    regex_pattern: str
    test_strings: List[str]


# API Endpoints
@router.post("/patterns/generate", response_model=PatternGenerateResponse)
async def generate_pattern_with_llm(request: PatternGenerateRequest):
    """
    Generate a PII detection pattern using LLM (GPT-5.2).
    
    Example:
        POST /pii/patterns/generate
        {
            "data_type_description": "contrase√±as de empleado",
            "context": "Formato interno de la empresa",
            "language": "es"
        }
    """
    logger.info(f"ü§ñ Generating pattern for: {request.data_type_description}")
    
    result = await llm_pattern_generator.generate_pattern(
        data_type_description=request.data_type_description,
        context=request.context,
        language=request.language
    )
    
    return PatternGenerateResponse(**result)


@router.post("/patterns", response_model=CustomPIIPatternResponse, status_code=status.HTTP_201_CREATED)
async def create_custom_pattern(
    pattern: CustomPIIPatternCreate,
    supabase=Depends(get_supabase)
):
    """
    Create a new custom PII pattern.
    Can be generated by LLM or manually defined.
    """
    # Validate scope
    scope_count = sum([
        pattern.tenant_id is not None,
        pattern.department_id is not None,
        pattern.user_id is not None
    ])
    
    if scope_count != 1:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Exactly one scope (tenant, department, or user) must be specified"
        )
    
    # Insert into database
    try:
        data = pattern.dict()
        if pattern.test_examples:
            data["test_examples"] = {"examples": pattern.test_examples}
        
        result = supabase.table("custom_pii_patterns").insert(data).execute()
        
        logger.info(f"‚úÖ Created custom PII pattern: {pattern.pattern_name}")
        
        return CustomPIIPatternResponse(**result.data[0])
        
    except Exception as e:
        logger.error(f"Failed to create pattern: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create pattern: {str(e)}"
        )


@router.get("/patterns", response_model=List[CustomPIIPatternResponse])
async def list_patterns(
    tenant_id: Optional[UUID] = None,
    department_id: Optional[UUID] = None,
    user_id: Optional[UUID] = None,
    active_only: bool = True,
    supabase=Depends(get_supabase)
):
    """
    List custom PII patterns for a given scope.
    Returns patterns in hierarchical order (Tenant ‚Üí Department ‚Üí User).
    """
    query = supabase.table("custom_pii_patterns").select("*")
    
    if active_only:
        query = query.eq("is_active", True)
    
    # Build hierarchical query
    if user_id:
        query = query.eq("user_id", user_id)
    elif department_id:
        query = query.eq("department_id", department_id)
    elif tenant_id:
        query = query.eq("tenant_id", tenant_id)
    
    result = query.execute()
    
    return [CustomPIIPatternResponse(**row) for row in result.data]


@router.put("/patterns/{pattern_id}", response_model=CustomPIIPatternResponse)
async def update_pattern(
    pattern_id: UUID,
    updates: dict,
    supabase=Depends(get_supabase)
):
    """Update an existing custom PII pattern."""
    try:
        result = supabase.table("custom_pii_patterns")\
            .update(updates)\
            .eq("id", pattern_id)\
            .execute()
        
        if not result.data:
            raise HTTPException(status_code=404, detail="Pattern not found")
        
        logger.info(f"‚úÖ Updated pattern: {pattern_id}")
        
        return CustomPIIPatternResponse(**result.data[0])
        
    except Exception as e:
        logger.error(f"Failed to update pattern: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.delete("/patterns/{pattern_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_pattern(
    pattern_id: UUID,
    supabase=Depends(get_supabase)
):
    """Delete a custom PII pattern."""
    try:
        result = supabase.table("custom_pii_patterns")\
            .delete()\
            .eq("id", pattern_id)\
            .execute()
        
        if not result.data:
            raise HTTPException(status_code=404, detail="Pattern not found")
        
        logger.info(f"üóëÔ∏è Deleted pattern: {pattern_id}")
        
    except Exception as e:
        logger.error(f"Failed to delete pattern: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/patterns/test")
async def test_pattern(request: PatternTestRequest):
    """
    Test a regex pattern against sample strings.
    Useful for validating patterns before saving.
    """
    result = llm_pattern_generator.test_pattern(
        pattern=request.regex_pattern,
        test_strings=request.test_strings
    )
    
    return result
