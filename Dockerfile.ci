# agentshield_core/Dockerfile.ci (Full Build for GitHub Actions)

# ETAPA 1: Builder (Compilación rápida)
FROM python:3.13-slim AS builder

# 1. Instalar dependencias del sistema incluyendo Tesseract OCR
# Usamos cache para apt para no descargar todo de nuevo cada vez
RUN rm -f /etc/apt/apt.conf.d/docker-clean; echo 'Binary::apt::APT::Keep-Downloaded-Packages "true";' > /etc/apt/apt.conf.d/keep-cache
RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
    --mount=type=cache,target=/var/lib/apt,sharing=locked \
    apt-get update && apt-get install -y \
    build-essential \
    libpq-dev \
    pkg-config \
    libssl-dev \
    curl \
    tesseract-ocr \
    libtesseract-dev \
    poppler-utils \
    && curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y

ENV PATH="/root/.cargo/bin:${PATH}"

# 2. Instalar UV y Maturin
COPY --from=ghcr.io/astral-sh/uv:latest /uv /bin/uv
ENV UV_COMPILE_BYTECODE=1
ENV UV_LINK_MODE=copy
# Usamos cache para pip/uv
RUN --mount=type=cache,target=/root/.cache/uv \
    uv pip install --system maturin

# 3. Instalar Dependencias Python (CACHEABLE - Heavy Step moved UP)
WORKDIR /app
COPY requirements.txt .
ENV UV_HTTP_TIMEOUT=120

# Instalamos primero FlashRank y descargamos el modelo (Capa cacheada si reqs.txt no cambia)
RUN --mount=type=cache,target=/root/.cache/uv \
    uv pip install --system flashrank

# --- FIX CRITICO: FORZAR TORCH CPU ---
# Transformers instala automáticamente Torch con CUDA (NVIDIA) lo que pesa >4GB y rompe el CI por espacio.
# Forzamos la instalación de la versión CPU (~150MB) desde el índice oficial de PyTorch.
RUN --mount=type=cache,target=/root/.cache/uv \
    uv pip install --system --index-url https://download.pytorch.org/whl/cpu torch

# Descarga de modelos (FlashRank / ONNX)
# Esto evita descargas en tiempo de ejecución.
RUN mkdir -p /app/model_cache && \
    python -c "from flashrank import Ranker; Ranker(model_name='ms-marco-MiniLM-L-12-v2', cache_dir='/app/model_cache')"

# Instalamos el resto de dependencias
RUN --mount=type=cache,target=/root/.cache/uv \
    uv pip install --system \
    -r requirements.txt

# 4. Compilar el Módulo Rust (Con Cache de Cargo) - Moved entries AFTER python deps
COPY rust_module /app/rust_module
WORKDIR /app/rust_module
ENV PYO3_USE_ABI3_FORWARD_COMPATIBILITY=1
# Cacheamos el registro y la carpeta target de cargo
RUN --mount=type=cache,target=/usr/local/cargo/registry \
    --mount=type=cache,target=/app/rust_module/target \
    maturin build --release --strip && \
    # Movemos el wheel fuera del target para que persista tras el build
    mkdir -p /app/dist && \
    cp target/wheels/*.whl /app/dist/

# 5. Instalar el Módulo Rust compilado
WORKDIR /app
RUN --mount=type=cache,target=/root/.cache/uv \
    uv pip install --system /app/dist/*.whl

# ETAPA 2: Runner (Imagen final ligera)
FROM python:3.13-slim

# Variables de optimización
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONOPTIMIZE=1 \
    MALLOC_ARENA_MAX=2 \
    HF_HOME=/opt/models \
    TRANSFORMERS_OFFLINE=1

WORKDIR /app

# Copiamos las librerías instaladas
COPY --from=builder /usr/local/lib/python3.13/site-packages /usr/local/lib/python3.13/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin

# Copiamos el modelo descargado a /opt/models (Debe coincidir con tu reranker.py)
COPY --from=builder /app/model_cache /opt/models

# Copiamos el código fuente
COPY ./app /app/app

# Usuario no-root y permisos para la carpeta de modelos
RUN useradd -m appuser && \
    chown -R appuser /app && \
    chown -R appuser /opt/models

USER appuser

# Comando de arranque: 1 worker y 1 thread de bloqueo para ASGI (tier 512MB)
CMD ["sh", "-c", "granian --interface asgi app.main:app --host 0.0.0.0 --port ${PORT:-10000} --workers 1 --blocking-threads 1"]
