# ðŸ§  4.2 Proxy: CachÃ© SemÃ¡ntico (`cache.py`)

> **Objetivo**: Explicar cÃ³mo ahorramos dinero detectando preguntas repetidas (o parecidas).
> **Archivo**: `app/services/cache.py`

---

## Estrategia de CachÃ© en Cascada (Waterfall)
No es un simple `if key in dict`. Es un sistema de 3 niveles.

### Tier 0: Match Exacto (Hash)
```python
prompt_hash = hashlib.sha256(prompt.encode()).hexdigest()
exact_hit = await redis_client.get(f"cache:exact:{hash}")
```
*   **Coste**: $0.00.
*   **Latencia**: 1-2 ms.
*   **Caso**: El usuario reintenta exactamente la misma peticiÃ³n.

### Tier 1: BÃºsqueda Vectorial (Redis VSS)
Si el hash falla, pasamos a la IA.
1.  **Embedding**: `get_embedding(prompt)`.
    *   Convierte texto a vector de 1536 dimensiones (`text-embedding-3-small` o local).
2.  **Vector Search**:
    ```python
    query = "*=>[KNN 3 @vector $vec as score]"
    res = await redis_client.ft("idx:cache").search(query)
    ```
    *   Busca los 3 vectores mÃ¡s cercanos en el espacio latente.

---

## 3. `init_semantic_cache_index`
Se ejecuta al inicio.
*   Crea un Ã­ndice `FLAT` o `HNSW` en Redis.
*   Define el esquema: `vector` (FLOAT32), `tenant_id` (Text), `response` (Text).

## 4. `verify_cache_logic` (Reranker)
*   Para evitar falsos positivos (que la IA diga que "SÃ­" es igual a "No"), usamos un Reranker (Cross-Encoder) como juez final.
*   Si la similitud vectorial es > 0.90 pero el reranker dice < 0.8, descartamos el cachÃ©.
