#  2.3 Seguridad: Endpoint de Autorizaci贸n (`authorize.py`)

> **Objetivo**: Explicar la toma de decisiones financieras y de seguridad.
> **Archivo**: `app/routers/authorize.py`

---

## 1. `get_tenant_from_header` (Helper)
```python
async def get_tenant_from_header(x_api_key: str = Header(...)):
```
*   **Funci贸n**: Inyector de dependencias de FastAPI.
*   **Detalle**: Intercepta la cabecera `X-Api-Key` antes de que la funci贸n principal se ejecute. Si la llave es inv谩lida, devuelve `401 Unauthorized` instant谩neamente. Usa Redis como cach茅 para no saturar la base de datos.

---

## 2. `authorize_transaction` (Endpoint Principal)
```python
@router.post("/v1/authorize")
async def authorize_transaction(...)
```
Es el cerebro de la operaci贸n. Ejecuta estas funciones en orden:

### A. Panic Mode Check
```python
if policy.get("panic_mode", False):
    return DENIED("EMERGENCY STOP ACTIVE")
```
*   Verifica si el administrador puls贸 el "Bot贸n Rojo" para detener todo el tr谩fico.

### B. Estimaci贸n de Costes
```python
cost_estimated = await estimator.estimate_cost(...)
```
*   Pregunta al `Estimator` (ver Doc 3.0) cu谩nto costar谩 esta petici贸n ANTES de hacerla.

### C. Compliance Check (EU AI Act)
```python
action = risk_rules.get(req.use_case.value, "ALLOW")
```
*   Si el caso de uso es `BIOMETRIC_ID` (Prohibido por la UE), devuelve `DENIED` autom谩ticamente sin importar el presupuesto.

### D. Governance & Budget
```python
if cost_estimated > approval_threshold:
    return PENDING_APPROVAL
```
*   Si el coste supera el umbral de "Manager Approval", pone la transacci贸n en espera.

### E. Smart Routing (El Broker)
```python
if decision == "DENIED" and "budget exceeded":
    # Intenta buscar un modelo m谩s barato
```
*   Si el usuario pidi贸 GPT-4 y no tiene saldo, el sistema intenta buscar un "modelo compatible" m谩s barato (ej. GPT-3.5) para salvar la transacci贸n autom谩ticamente.

---

## 3. `get_current_spend` (Redis Cache)
```python
async def get_current_spend(tenant_id, cost_center_id):
```
*   **Funci贸n**: Lee cu谩nto lleva gastado el cliente.
*   **Problema**: Calcular `SUM(cost)` de 1 mill贸n de filas es lento.
*   **Soluci贸n**: Mantenemos un contador at贸mico en Redis (`INCRBY`). Solo leemos la DB si Redis se vac铆a.
