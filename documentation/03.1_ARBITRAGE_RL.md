#  3.1 Financiero: Arbitraje RL (`arbitrage.py`)

> **Objetivo**: Explicar c贸mo el sistema aprende qu茅 modelos son baratos y buenos.
> **Archivo**: `app/services/arbitrage.py`

---

## El Concepto: "Bandido Contextual"
No usamos reglas fijas ("Si es lunes usa GPT-4"). Usamos **Reinforcement Learning** (Q-Learning). El sistema trata cada petici贸n como una apuesta en un casino:
*   **Estado**: 驴Qu茅 tan dif铆cil es la petici贸n? (Complejidad del prompt).
*   **Acci贸n**: 驴Qu茅 modelo uso? (GPT-4o, Haiku, Llama-3).
*   **Recompensa**: (Precisi贸n - Coste - Latencia).

---

## 1. `_get_state_key` (Discretizaci贸n)
```python
def _get_state_key(self, complexity_score: float, input_tokens: int) -> str:
```
*   **Problema**: El mundo real es continuo (complejidad 87.432%). La tabla Q necesita estados finitos.
*   **Soluci贸n**: Convertimos los n煤meros en "Cubos" (Buckets).
    *   **Complejidad**: `TRIVIAL` (0-20), `EASY` (20-40), `MEDIUM`, `HARD`, `EXTREME`.
    *   **Longitud**: `SHORT` (0-500), `MEDIUM`, `LONG`, `HUGE`.
*   **Resultado**: Un estado legible como `MEDIUM:SHORT`. Esto reduce el espacio de estados a ~20 combinaciones, permitiendo que el aprendizaje converja en d铆as, no a帽os.

---

## 2. `find_best_bidder` (Epsilon-Greedy)
```python
async def find_best_bidder(self, requested_model, ...):
```
*   **Exploraci贸n (Epsilon = 0.1)**: El 10% de las veces, elegimos un modelo al azar.
    *   *Por qu茅*: Quiz谩s Llama-3 ha mejorado hoy. Si nunca lo probamos, nunca lo sabremos.
*   **Explotaci贸n (90%)**: Elegimos el modelo con el mejor **Q-Value** hist贸rico para este estado.
    *   *L贸gica*: "Para tareas `EASY:SHORT`, Haiku me da 0.95 de recompensa promedio, GPT-4 solo 0.8 (por el precio)". Haiku gana.

---

## 3. `update_q_value` (Aprendizaje)
```python
async def update_q_value(self, state, model, reward):
```
*   Se llama **despu茅s** de que el usuario recibe su respuesta.
*   **F贸rmula Q-Learning**:
    `Nuevo_Q = Viejo_Q + alpha * (Recompensa - Viejo_Q)`
*   Si un modelo falla o tarda mucho, su Q-Value baja. La pr贸xima vez, ser谩 menos probable que lo elijamos para ese tipo de tarea.

---

## 4. `analyze_prompt_complexity` (El Juez)
```python
def analyze_prompt_complexity(text):
```
*   Usa heur铆sticas r谩pidas (longitud de palabras, palabras clave como "c贸digo", "json", "explicar") para asignar una puntuaci贸n 0-100 antes de llamar a la IA.
