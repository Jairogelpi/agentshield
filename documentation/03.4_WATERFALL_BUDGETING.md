# 03.4 Waterfall Budgeting (Presupuesto en Cascada)

El control de costes en AgentShield trasciende los límites simples por API Key. Implementamos un sistema de **Presupuesto Jerárquico** ("Waterfall") que verifica la solvencia en tres niveles organizativos simultáneamente antes de autorizar cualquier gasto.

## La Regla de Hierro (The Iron Rule)
Para que una transacción sea aprobada, *todos* los niveles de la jerarquía deben tener fondos suficientes. Si falla uno, la cadena se rompe y la petición se bloquea (`402 Payment Required`).

### Jerarquía de Wallets
1.  **Tenant Wallet (Nivel Empresa)**: El presupuesto global de la organización. Si la empresa no paga la factura, nadie puede gastar.
2.  **Department Wallet (Nivel Cost Center)**: El presupuesto asignado a un departamento (ej. Marketing, Ingeniería). Evita que un departamento drene los recursos de toda la empresa.
3.  **User Wallet (Nivel Individual)**: La asignación personal ("allowance") de cada empleado. Controla el uso abusivo a nivel individual.

## Implementación Técnica (`app/services/limiter.py`)

### Verificación Atómica (Redis Pipeline)
La verificación debe ser instantánea para no añadir latencia a la IA. Utilizamos Redis `MGET` para recuperar los saldos de los tres wallets en una sola operación de red (< 2ms).

```python
# Pseudocódigo de la lógica de verificación
bal_tenant, bal_dept, bal_user = redis.mget(keys_tenant, keys_dept, keys_user)

if bal_tenant < cost_est: raise "Corporate funds exhausted"
if bal_dept   < cost_est: raise "Department budget exceeded"
if bal_user   < cost_est: raise "Personal allowance exhausted"
```

### Cobro Atómico Post-Ejecución
Una vez finalizada la inferencia y calculado el coste real preciso, el cobro se ejecuta de forma atómica en background:
- Se decrementa el coste del **Tenant Wallet**.
- Se decrementa el coste del **Dept Wallet**.
- Se decrementa el coste del **User Wallet**.

Esto mantiene la consistencia contable en todo momento.

## Schema SQL (`wallets`)
Los saldos se persisten en PostgreSQL en la tabla `wallets`, diseñada con constraints `UNIQUE` para asegurar que cada entidad (Tenant, Dept, User) tenga un único wallet activo de cada tipo.

```sql
CREATE TABLE wallets (
    id UUID PRIMARY KEY,
    type TEXT CHECK (type IN ('tenant', 'dept', 'user')),
    balance DECIMAL(20, 4),
    -- ... FKs a tenant_id, department_id, user_id
);
```
